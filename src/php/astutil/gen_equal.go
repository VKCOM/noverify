// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"path"
	"sort"
	"strings"
)

type packageData struct {
	name  string
	scope *types.Scope
	types []*typeData
}

type typeData struct {
	name string
	info *types.Struct
}

type context struct {
	fset     *token.FileSet
	packages []*packageData
}

func main() {
	packages := []string{
		"parser/node",
		"parser/node/stmt",
		"parser/node/name",
		"parser/node/scalar",
		"parser/node/expr",
		"parser/node/expr/binary",
		"parser/node/expr/cast",
		"parser/node/expr/assign",
	}

	ctx := context{
		fset: token.NewFileSet(),
	}
	for _, pkg := range packages {
		if err := loadPackage(&ctx, pkg); err != nil {
			log.Fatalf("load %s: %v", pkg, err)
		}
	}
	sortSymbols(&ctx)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by `gen_equal.go`. DO NOT EDIT.\n")
	buf.WriteString("package astutil\n")
	buf.WriteString("import (\n")
	for _, path := range importPaths(packages) {
		buf.WriteString("  \"" + path + "\"\n")
	}
	buf.WriteString(")\n")
	buf.WriteString("func NodeEqual(x, y node.Node) bool {\n")
	buf.WriteString("  if x == nil || y == nil { return x == y }\n")
	buf.WriteString("  switch x := x.(type) {\n")
	for _, pkg := range ctx.packages {
		for _, typ := range pkg.types {
			fmt.Fprintf(&buf, "  case *%s.%s:\n", pkg.name, typ.name)
			writeCompare(&buf, pkg, typ)
			buf.WriteString("    return true\n")
		}
	}
	buf.WriteString("  default:\n")
	buf.WriteString("    panic(fmt.Sprintf(`unhandled type %T`, x))")
	buf.WriteString("  }\n")
	buf.WriteString("}\n")

	output, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("gofmt: %v", err)
	}

	if err := ioutil.WriteFile("equal.go", output, 0666); err != nil {
		log.Fatalf("write file: %v", err)
	}
}

func writeCompare(w *bytes.Buffer, pkg *packageData, typ *typeData) {
	fmt.Fprintf(w, "    y, ok := y.(*%s.%s)\n", pkg.name, typ.name)
	w.WriteString("    if !ok || x == nil || y == nil { return x == y }\n")
	for i := 0; i < typ.info.NumFields(); i++ {
		field := typ.info.Field(i)
		switch typeString := field.Type().String(); typeString {
		case "string", "bool":
			fmt.Fprintf(w, "    if x.%[1]s != y.%[1]s { return false }\n", field.Name())
		case "github.com/VKCOM/noverify/src/php/parser/node.Node":
			fmt.Fprintf(w, "    if !NodeEqual(x.%[1]s, y.%[1]s) { return false }\n", field.Name())
		case "[]github.com/VKCOM/noverify/src/php/parser/node.Node":
			fmt.Fprintf(w, "    if !NodeSliceEqual(x.%[1]s, y.%[1]s) { return false }\n", field.Name())
		case "github.com/VKCOM/noverify/src/php/parser/freefloating.Collection":
			// Do nothing.
		case "*github.com/VKCOM/noverify/src/php/parser/position.Position":
			// Do nothing.
		default:
			if !strings.HasPrefix(typeString, "[]") {
				fmt.Fprintf(w, "    if !NodeEqual(x.%[1]s, y.%[1]s) { return false }\n", field.Name())
				continue
			}
			fmt.Fprintf(w, "    if len(x.%[1]s) != len(y.%[1]s) { return false }\n", field.Name())
			fmt.Fprintf(w, "    for i := range x.%s {\n", field.Name())
			fmt.Fprintf(w, "      if !NodeEqual(x.%[1]s[i], y.%[1]s[i]) { return false }\n", field.Name())
			fmt.Fprintf(w, "    }\n")
		}
	}
}

func importPaths(packages []string) []string {
	paths := make([]string, len(packages))
	for i, pkg := range packages {
		paths[i] = "github.com/VKCOM/noverify/src/php/" + pkg
	}
	paths = append(paths, "fmt")
	return paths
}

var typechecker = types.Config{
	Importer: importer.For("source", nil),
}

func loadPackage(ctx *context, pkg string) error {
	pkgName := path.Base(pkg)
	parsedPkgs, err := parser.ParseDir(ctx.fset, "../"+pkg, nil, 0)
	if err != nil {
		return err
	}
	astPkg, ok := parsedPkgs[pkgName]
	if !ok {
		return fmt.Errorf("package %s not found", pkgName)
	}
	astFiles := make([]*ast.File, 0, len(astPkg.Files))
	for _, f := range astPkg.Files {
		astFiles = append(astFiles, f)
	}
	var info types.Info
	typesPkg, err := typechecker.Check(pkg, ctx.fset, astFiles, &info)
	if err != nil {
		return err
	}
	root := typesPkg.Scope()
	result := &packageData{
		name:  pkgName,
		scope: root,
	}
	for _, sym := range root.Names() {
		tn, ok := root.Lookup(sym).(*types.TypeName)
		if !ok {
			continue
		}
		named, ok := tn.Type().(*types.Named)
		if !ok {
			continue
		}
		structType, ok := named.Underlying().(*types.Struct)
		if !ok {
			continue
		}
		result.types = append(result.types, &typeData{
			name: tn.Name(),
			info: structType,
		})
	}
	ctx.packages = append(ctx.packages, result)
	return nil
}

func sortSymbols(ctx *context) {
	sort.Slice(ctx.packages, func(i, j int) bool {
		return ctx.packages[i].name < ctx.packages[j].name
	})
	for _, pkg := range ctx.packages {
		sort.Slice(pkg.types, func(i, j int) bool {
			return pkg.types[i].name < pkg.types[j].name
		})
	}
}
