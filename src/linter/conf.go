package linter

import (
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/VKCOM/php-parser/pkg/version"
	"github.com/client9/misspell"

	"github.com/VKCOM/noverify/src/baseline"
	"github.com/VKCOM/noverify/src/inputs"
	"github.com/VKCOM/noverify/src/rules"
)

type Config struct {
	// BaselineProfile is a suppression database for warnings.
	// Nil profile is an empty suppression profile.
	BaselineProfile       *baseline.Profile
	ComputeBaselineHashes bool // Whether we need to compute report hashes
	ConservativeBaseline  bool

	ApplyQuickFixes bool

	// KPHP tells whether we're working in KPHP-compatible mode.
	KPHP bool

	CacheDir string

	// TypoFixer is a rule set for English typos correction.
	// If nil, no misspell checking is performed.
	// See github.com/client9/misspell for details.
	TypoFixer *misspell.Replacer

	// SrcInput implements source code reading from files and buffers.
	SrcInput inputs.SourceInput

	// Rules is a set of dynamically loaded linter diagnostics.
	Rules *rules.Set

	// PathRules is a set of specific rules for paths.
	PathRules *RuleNode

	// settings

	ProjectPath string

	StubsDir string
	Debug    bool

	// MaxConcurrency limits the linter concurrency.
	MaxConcurrency int

	// DebugParseDuration specifies the minimum parse duration for it to be printed to debug output.
	DebugParseDuration time.Duration

	CheckAutoGenerated bool

	IsDiscardVar func(varname string) bool

	ExcludeRegex *regexp.Regexp

	AllowDisable *regexp.Regexp

	PhpExtensions []string

	Checkers *CheckersRegistry

	IgnoreTriggerError bool

	PhpVersion *version.Version

	StrictMixed bool
}

type RuleNode struct {
	Children map[string]*RuleNode // Child nodes (subdirectories and files)
	Enable   map[string]bool      // Rules enabled at this level
	Disable  map[string]bool      // Disabled rules at this level
}

func NewRuleNode() *RuleNode {
	return &RuleNode{
		Children: make(map[string]*RuleNode),
		Enable:   make(map[string]bool),
		Disable:  make(map[string]bool),
	}
}

type PathRuleSet struct {
	Enable  map[string]bool // Rules that are enabled for this path
	Disable map[string]bool // Rules that are disabled for this path
}

func BuildRuleTree(pathRules map[string]*PathRuleSet) *RuleNode {
	root := NewRuleNode()

	for path, ruleSet := range pathRules {
		normalizedPath := filepath.ToSlash(filepath.Clean(path))
		parts := strings.Split(normalizedPath, "/")
		currentNode := root

		for _, part := range parts {
			if part == "" {
				continue
			}
			if _, exists := currentNode.Children[part]; !exists {
				currentNode.Children[part] = NewRuleNode()
			}
			currentNode = currentNode.Children[part]
		}

		for rule := range ruleSet.Enable {
			currentNode.Enable[rule] = true
		}
		for rule := range ruleSet.Disable {
			currentNode.Disable[rule] = true
		}
	}

	return root
}

func IsRuleEnabled(root *RuleNode, filePath string, checkRule string) bool {
	normalizedPath := filepath.ToSlash(filepath.Clean(filePath))
	parts := strings.Split(normalizedPath, "/")
	currentNode := root

	// Starting with global state. We have guarantee while parsing config that rule is `on` and exist
	ruleState := true

	for _, part := range parts {
		if part == "" {
			continue
		}
		if node, exists := currentNode.Children[part]; exists {
			if node.Disable[checkRule] {
				ruleState = false // Disable on this path
			}
			if node.Enable[checkRule] {
				ruleState = true // Enable on this path
			}
			currentNode = node
		} else {
			break
		}
	}

	return ruleState
}

func NewConfig(ver string) *Config {
	reg := &CheckersRegistry{
		info: map[string]CheckerInfo{},
	}

	phpVersion, _ := version.New(ver)

	addBuiltinCheckers(reg)
	return &Config{
		SrcInput:       inputs.NewDefaultSourceInput(),
		Rules:          rules.NewSet(),
		PathRules:      NewRuleNode(),
		MaxConcurrency: runtime.NumCPU(),
		IsDiscardVar:   isUnderscore,
		Checkers:       reg,
		PhpVersion:     phpVersion,
	}
}
