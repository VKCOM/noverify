package workspace

import (
	"bytes"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/karrick/godirwalk"

	"github.com/VKCOM/noverify/src/git"
)

type ReadCallback func(ch chan FileInfo)

type FileInfo struct {
	Filename   string
	Contents   []byte
	LineRanges []git.LineRange
}

func FileIsAutoGenerated(contents []byte) bool {
	src := contents
	maxLinesPeek := 15

	doNotEdit := false
	autoGenerated := false

	for line := 0; line < maxLinesPeek; line++ {
		if doNotEdit && autoGenerated {
			return true
		}
		newline := bytes.IndexByte(src, '\n')
		if newline == -1 {
			break
		}

		l := strings.ToLower(string(src[:newline]))
		src = src[newline+len("\n"):]

		looksLikeComment := strings.HasPrefix(l, "//") ||
			strings.HasPrefix(l, "/*") ||
			strings.HasPrefix(l, " *")
		if !looksLikeComment {
			continue
		}

		doNotEdit = doNotEdit ||
			strings.Contains(l, "do not edit") ||
			strings.Contains(l, "don't edit") ||
			strings.Contains(l, "do not modify") ||
			strings.Contains(l, "don't modify")
		autoGenerated = autoGenerated ||
			strings.Contains(l, "auto-generated") ||
			strings.Contains(l, "autogenerated") ||
			strings.Contains(l, "generated by")
	}

	return doNotEdit && autoGenerated
}

// ReadFilenames returns callback that reads filenames into channel
func ReadFilenames(filenames []string, filter *FilenameFilter) ReadCallback {
	return func(ch chan FileInfo) {
		for _, filename := range filenames {
			readFilenames(ch, filename, filter)
		}
	}
}

func readFilenames(ch chan<- FileInfo, filename string, filter *FilenameFilter) {
	absFilename, err := filepath.Abs(filename)
	if err == nil {
		filename = absFilename
	}

	if filter == nil {
		// No-op filter that doesn't track gitignore files.
		filter = &FilenameFilter{}
	}

	// If we use stat here, it will return file info of an entry
	// pointed by a symlink (if filename is a link).
	// lstat is required for a symlink test below to succeed.
	// If we ever want to permit top-level (CLI args) symlinks,
	// caller should resolve them to a files that are pointed by them.
	st, err := os.Lstat(filename)
	if err != nil {
		log.Fatalf("Could not stat file %s: %s", filename, err.Error())
	}
	if st.Mode()&os.ModeSymlink != 0 {
		// filepath.Walk does not follow symlinks, but it does
		// accept it as a root argument without an error.
		// godirwalk.Walk can traverse symlinks with FollowSymbolicLinks=true,
		// but we don't use it. It will give an error if root is
		// a symlink, so we avoid calling Walk() on them.
		return
	}

	if !st.IsDir() {
		if filter.IgnoreFile(filename) {
			return
		}

		if !isPHPExtension(filename) {
			return
		}

		ch <- FileInfo{Filename: filename}
		return
	}

	// Start with a sentinel "" path to make last(gitignorePaths) safe
	// without a length check.
	gitignorePaths := []string{""}

	walkOptions := &godirwalk.Options{
		Unsorted: true,

		Callback: func(path string, de *godirwalk.Dirent) error {
			if de.IsDir() {
				if filter.IgnoreDir(path) {
					return filepath.SkipDir
				}
				// During indexing phase and with -gitignore=false
				// we don't want to do extra FS operations.
				if !filter.GitignoreIsEnabled() {
					return nil
				}

				matcher, err := ParseGitignoreFromDir(path)
				if err != nil {
					log.Printf("read .gitignore: %v", err)
				}
				if matcher != nil {
					gitignorePaths = append(gitignorePaths, path)
					filter.GitignorePush(path, matcher)
				}
				return nil
			}

			if !isPHPExtension(path) {
				return nil
			}
			if filter.IgnoreFile(path) {
				return nil
			}

			ch <- FileInfo{Filename: path}
			return nil
		},
	}

	if filter.GitignoreIsEnabled() {
		walkOptions.PostChildrenCallback = func(path string, de *godirwalk.Dirent) error {
			topGitignorePath := gitignorePaths[len(gitignorePaths)-1]
			if topGitignorePath == path {
				gitignorePaths = gitignorePaths[:len(gitignorePaths)-1]
				filter.GitignorePop(path)
			}
			return nil
		}
	}

	if err := godirwalk.Walk(filename, walkOptions); err != nil {
		log.Fatalf("Could not walk filepath %s (%v)", filename, err)
	}
}

var PHPExtensions = []string{"php", "inc", "php5", "phtml"}

func isPHPExtension(filename string) bool {
	fileExt := filepath.Ext(filename)
	if fileExt == "" {
		return false
	}

	fileExt = fileExt[len("."):]

	for _, ext := range PHPExtensions {
		if fileExt == ext {
			return true
		}
	}

	return false
}
