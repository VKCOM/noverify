// Code generated by the `ir/codegen` package. DO NOT EDIT.
package ir

import (
	"fmt"
	"github.com/z7zmey/php-parser/pkg/token"
)

func GetFirstToken(n Node) *token.Token {
	switch n := n.(type) {
	case *AnonClassExpr:
		if n.ClassTkn != nil {
			return n.ClassTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Args) != 0 {
			return GetFirstToken(n.Args[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *Argument:
		if n.VariadicTkn != nil {
			return n.VariadicTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		return GetFirstToken(n.Expr)
	case *ArrayDimFetchExpr:
		return GetFirstToken(n.Variable)
		if n.OpenBracketTkn != nil {
			return n.OpenBracketTkn
		}
		return GetFirstToken(n.Dim)
		if n.CloseBracketTkn != nil {
			return n.CloseBracketTkn
		}
	case *ArrayExpr:
		if n.ArrayTkn != nil {
			return n.ArrayTkn
		}
		if n.OpenBracketTkn != nil {
			return n.OpenBracketTkn
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseBracketTkn != nil {
			return n.CloseBracketTkn
		}
	case *ArrayItemExpr:
		if n.EllipsisTkn != nil {
			return n.EllipsisTkn
		}
		return GetFirstToken(n.Key)
		if n.DoubleArrowTkn != nil {
			return n.DoubleArrowTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		return GetFirstToken(n.Val)
	case *ArrowFunctionExpr:
		if n.StaticTkn != nil {
			return n.StaticTkn
		}
		if n.FnTkn != nil {
			return n.FnTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Params) != 0 {
			return GetFirstToken(n.Params[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.ReturnType)
		if n.DoubleArrowTkn != nil {
			return n.DoubleArrowTkn
		}
		return GetFirstToken(n.Expr)
	case *Assign:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignBitwiseAnd:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignBitwiseOr:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignBitwiseXor:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignCoalesce:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignConcat:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignDiv:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignMinus:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignMod:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignMul:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignPlus:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignPow:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignReference:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignShiftLeft:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *AssignShiftRight:
		return GetFirstToken(n.Variable)
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expression)
	case *BadString:
		if n.MinusTkn != nil {
			return n.MinusTkn
		}
		if n.StringTkn != nil {
			return n.StringTkn
		}
	case *BitwiseAndExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *BitwiseNotExpr:
		if n.TildaTkn != nil {
			return n.TildaTkn
		}
		return GetFirstToken(n.Expr)
	case *BitwiseOrExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *BitwiseXorExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *BooleanAndExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *BooleanNotExpr:
		if n.ExclamationTkn != nil {
			return n.ExclamationTkn
		}
		return GetFirstToken(n.Expr)
	case *BooleanOrExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *BreakStmt:
		if n.BreakTkn != nil {
			return n.BreakTkn
		}
		return GetFirstToken(n.Expr)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *CaseStmt:
		if n.CaseTkn != nil {
			return n.CaseTkn
		}
		return GetFirstToken(n.Cond)
		if n.CaseSeparatorTkn != nil {
			return n.CaseSeparatorTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
	case *CatchStmt:
		if n.CatchTkn != nil {
			return n.CatchTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Types) != 0 {
			return GetFirstToken(n.Types[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *ClassConstFetchExpr:
		return GetFirstToken(n.Class)
		if n.DoubleColonTkn != nil {
			return n.DoubleColonTkn
		}
	case *ClassConstListStmt:
		if n.ConstTkn != nil {
			return n.ConstTkn
		}
		if len(n.Consts) != 0 {
			return GetFirstToken(n.Consts[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *ClassExtendsStmt:
		if n.ExtendsTkn != nil {
			return n.ExtendsTkn
		}
	case *ClassImplementsStmt:
		if n.ImplementsTkn != nil {
			return n.ImplementsTkn
		}
		if len(n.ImplementsSeparatorTkns) != 0 {
			return n.ImplementsSeparatorTkns[0]
		}
		if len(n.InterfaceNames) != 0 {
			return GetFirstToken(n.InterfaceNames[0])
		}
	case *ClassMethodStmt:
		if n.FunctionTkn != nil {
			return n.FunctionTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Params) != 0 {
			return GetFirstToken(n.Params[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.ReturnType)
		return GetFirstToken(n.Stmt)
	case *ClassStmt:
		if n.ClassTkn != nil {
			return n.ClassTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *CloneExpr:
		if n.CloneTkn != nil {
			return n.CloneTkn
		}
		return GetFirstToken(n.Expr)
	case *ClosureExpr:
		if n.StaticTkn != nil {
			return n.StaticTkn
		}
		if n.FunctionTkn != nil {
			return n.FunctionTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Params) != 0 {
			return GetFirstToken(n.Params[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.ReturnType)
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *ClosureUsesExpr:
		if n.UseTkn != nil {
			return n.UseTkn
		}
		if n.UseOpenParenthesisTkn != nil {
			return n.UseOpenParenthesisTkn
		}
		if len(n.Uses) != 0 {
			return GetFirstToken(n.Uses[0])
		}
		if len(n.UseSeparatorTkns) != 0 {
			return n.UseSeparatorTkns[0]
		}
		if n.UseCloseParenthesisTkn != nil {
			return n.UseCloseParenthesisTkn
		}
	case *CoalesceExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *ConcatExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *ConstFetchExpr:
	case *ConstListStmt:
		if n.ConstTkn != nil {
			return n.ConstTkn
		}
		if len(n.Consts) != 0 {
			return GetFirstToken(n.Consts[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *ConstantStmt:
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expr)
	case *ContinueStmt:
		if n.ContinueTkn != nil {
			return n.ContinueTkn
		}
		return GetFirstToken(n.Expr)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *DeclareStmt:
		if n.DeclareTkn != nil {
			return n.DeclareTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Consts) != 0 {
			return GetFirstToken(n.Consts[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
		if n.EndDeclareTkn != nil {
			return n.EndDeclareTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *DefaultStmt:
		if n.DefaultTkn != nil {
			return n.DefaultTkn
		}
		if n.CaseSeparatorTkn != nil {
			return n.CaseSeparatorTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
	case *DivExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *Dnumber:
		if n.NumberTkn != nil {
			return n.NumberTkn
		}
	case *DoStmt:
		if n.DoTkn != nil {
			return n.DoTkn
		}
		return GetFirstToken(n.Stmt)
		if n.WhileTkn != nil {
			return n.WhileTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Cond)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *EchoStmt:
		if n.EchoTkn != nil {
			return n.EchoTkn
		}
		if len(n.Exprs) != 0 {
			return GetFirstToken(n.Exprs[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *ElseIfStmt:
		if n.ElseIfTkn != nil {
			return n.ElseIfTkn
		}
		if n.ElseTkn != nil {
			return n.ElseTkn
		}
		if n.IfTkn != nil {
			return n.IfTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Cond)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
	case *ElseStmt:
		if n.ElseTkn != nil {
			return n.ElseTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
	case *EmptyExpr:
		if n.EmptyTkn != nil {
			return n.EmptyTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Expr)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *Encapsed:
		if n.OpenQuoteTkn != nil {
			return n.OpenQuoteTkn
		}
		if len(n.Parts) != 0 {
			return GetFirstToken(n.Parts[0])
		}
		if n.CloseQuoteTkn != nil {
			return n.CloseQuoteTkn
		}
	case *EncapsedStringPart:
		if n.EncapsedStrTkn != nil {
			return n.EncapsedStrTkn
		}
	case *EqualExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *ErrorSuppressExpr:
		if n.AtTkn != nil {
			return n.AtTkn
		}
		return GetFirstToken(n.Expr)
	case *EvalExpr:
		if n.EvalTkn != nil {
			return n.EvalTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Expr)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *ExitExpr:
		if n.ExitTkn != nil {
			return n.ExitTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Expr)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *ExpressionStmt:
		return GetFirstToken(n.Expr)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *FinallyStmt:
		if n.FinallyTkn != nil {
			return n.FinallyTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *ForStmt:
		if n.ForTkn != nil {
			return n.ForTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Init) != 0 {
			return GetFirstToken(n.Init[0])
		}
		if len(n.InitSeparatorTkns) != 0 {
			return n.InitSeparatorTkns[0]
		}
		if n.InitSemiColonTkn != nil {
			return n.InitSemiColonTkn
		}
		if len(n.Cond) != 0 {
			return GetFirstToken(n.Cond[0])
		}
		if len(n.CondSeparatorTkns) != 0 {
			return n.CondSeparatorTkns[0]
		}
		if n.CondSemiColonTkn != nil {
			return n.CondSemiColonTkn
		}
		if len(n.Loop) != 0 {
			return GetFirstToken(n.Loop[0])
		}
		if len(n.LoopSeparatorTkns) != 0 {
			return n.LoopSeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
		if n.EndForTkn != nil {
			return n.EndForTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *ForeachStmt:
		if n.ForeachTkn != nil {
			return n.ForeachTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Expr)
		if n.AsTkn != nil {
			return n.AsTkn
		}
		return GetFirstToken(n.Key)
		if n.DoubleArrowTkn != nil {
			return n.DoubleArrowTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		return GetFirstToken(n.Variable)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
		if n.EndForeachTkn != nil {
			return n.EndForeachTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *FunctionCallExpr:
		return GetFirstToken(n.Function)
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Args) != 0 {
			return GetFirstToken(n.Args[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *FunctionStmt:
		if n.FunctionTkn != nil {
			return n.FunctionTkn
		}
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Params) != 0 {
			return GetFirstToken(n.Params[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.ReturnType)
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *GlobalStmt:
		if n.GlobalTkn != nil {
			return n.GlobalTkn
		}
		if len(n.Vars) != 0 {
			return GetFirstToken(n.Vars[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *GotoStmt:
		if n.GotoTkn != nil {
			return n.GotoTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *GreaterExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *GreaterOrEqualExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *GroupUseStmt:
		if n.UseTkn != nil {
			return n.UseTkn
		}
		if n.LeadingNsSeparatorTkn != nil {
			return n.LeadingNsSeparatorTkn
		}
		if n.NsSeparatorTkn != nil {
			return n.NsSeparatorTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.UseList) != 0 {
			return GetFirstToken(n.UseList[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *HaltCompilerStmt:
		if n.HaltCompilerTkn != nil {
			return n.HaltCompilerTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *Heredoc:
		if n.OpenHeredocTkn != nil {
			return n.OpenHeredocTkn
		}
		if len(n.Parts) != 0 {
			return GetFirstToken(n.Parts[0])
		}
		if n.CloseHeredocTkn != nil {
			return n.CloseHeredocTkn
		}
	case *IdenticalExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *Identifier:
		if n.IdentifierTkn != nil {
			return n.IdentifierTkn
		}
	case *IfStmt:
		if n.IfTkn != nil {
			return n.IfTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Cond)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
		if len(n.ElseIf) != 0 {
			return GetFirstToken(n.ElseIf[0])
		}
		return GetFirstToken(n.Else)
		if n.EndIfTkn != nil {
			return n.EndIfTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
		if n.ElseTkn != nil {
			return n.ElseTkn
		}
	case *ImportExpr:
		if n.ImportTkn != nil {
			return n.ImportTkn
		}
		return GetFirstToken(n.Expr)
	case *InlineHTMLStmt:
		if n.InlineHTMLTkn != nil {
			return n.InlineHTMLTkn
		}
	case *InstanceOfExpr:
		return GetFirstToken(n.Expr)
		if n.InstanceOfTkn != nil {
			return n.InstanceOfTkn
		}
		return GetFirstToken(n.Class)
	case *InterfaceExtendsStmt:
		if n.ExtendsTkn != nil {
			return n.ExtendsTkn
		}
		if len(n.InterfaceNames) != 0 {
			return GetFirstToken(n.InterfaceNames[0])
		}
		if len(n.ExtendsSeparatorTkns) != 0 {
			return n.ExtendsSeparatorTkns[0]
		}
	case *InterfaceStmt:
		if n.InterfaceTkn != nil {
			return n.InterfaceTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *IssetExpr:
		if n.IssetTkn != nil {
			return n.IssetTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Variables) != 0 {
			return GetFirstToken(n.Variables[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *LabelStmt:
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
	case *ListExpr:
		if n.ListTkn != nil {
			return n.ListTkn
		}
		if n.OpenBracketTkn != nil {
			return n.OpenBracketTkn
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseBracketTkn != nil {
			return n.CloseBracketTkn
		}
	case *Lnumber:
		if n.NumberTkn != nil {
			return n.NumberTkn
		}
	case *LogicalAndExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *LogicalOrExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *LogicalXorExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *MagicConstant:
		if n.MagicConstTkn != nil {
			return n.MagicConstTkn
		}
	case *MethodCallExpr:
		return GetFirstToken(n.Variable)
		if n.ObjectOperatorTkn != nil {
			return n.ObjectOperatorTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		return GetFirstToken(n.Method)
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Args) != 0 {
			return GetFirstToken(n.Args[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *MinusExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *ModExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *MulExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *Name:
		if n.NameTkn != nil {
			return n.NameTkn
		}
	case *NamespaceStmt:
		if n.NsTkn != nil {
			return n.NsTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *NewExpr:
		if n.NewTkn != nil {
			return n.NewTkn
		}
		return GetFirstToken(n.Class)
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Args) != 0 {
			return GetFirstToken(n.Args[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *NopStmt:
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *NotEqualExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *NotIdenticalExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *Nullable:
		if n.QuestionTkn != nil {
			return n.QuestionTkn
		}
		return GetFirstToken(n.Expr)
	case *Parameter:
		return GetFirstToken(n.VariableType)
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		if n.VariadicTkn != nil {
			return n.VariadicTkn
		}
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.DefaultValue)
	case *ParenExpr:
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Expr)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *PlusExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *PostDecExpr:
		return GetFirstToken(n.Variable)
		if n.DecTkn != nil {
			return n.DecTkn
		}
	case *PostIncExpr:
		return GetFirstToken(n.Variable)
		if n.IncTkn != nil {
			return n.IncTkn
		}
	case *PowExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *PreDecExpr:
		if n.DecTkn != nil {
			return n.DecTkn
		}
		return GetFirstToken(n.Variable)
	case *PreIncExpr:
		if n.IncTkn != nil {
			return n.IncTkn
		}
		return GetFirstToken(n.Variable)
	case *PrintExpr:
		if n.PrintTkn != nil {
			return n.PrintTkn
		}
		return GetFirstToken(n.Expr)
	case *PropertyFetchExpr:
		return GetFirstToken(n.Variable)
		if n.ObjectOperatorTkn != nil {
			return n.ObjectOperatorTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		return GetFirstToken(n.Property)
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *PropertyListStmt:
		return GetFirstToken(n.Type)
		if len(n.Properties) != 0 {
			return GetFirstToken(n.Properties[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *PropertyStmt:
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expr)
	case *ReferenceExpr:
		if n.AmpersandTkn != nil {
			return n.AmpersandTkn
		}
		return GetFirstToken(n.Variable)
	case *ReturnStmt:
		if n.ReturnTkn != nil {
			return n.ReturnTkn
		}
		return GetFirstToken(n.Expr)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *Root:
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.EndTkn != nil {
			return n.EndTkn
		}
	case *ShellExecExpr:
		if n.OpenBacktickTkn != nil {
			return n.OpenBacktickTkn
		}
		if len(n.Parts) != 0 {
			return GetFirstToken(n.Parts[0])
		}
		if n.CloseBacktickTkn != nil {
			return n.CloseBacktickTkn
		}
	case *ShiftLeftExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *ShiftRightExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *SimpleVar:
		if n.DollarTkn != nil {
			return n.DollarTkn
		}
		if n.IdentifierTkn != nil {
			return n.IdentifierTkn
		}
	case *SmallerExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *SmallerOrEqualExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *SpaceshipExpr:
		return GetFirstToken(n.Left)
		if n.OpTkn != nil {
			return n.OpTkn
		}
		return GetFirstToken(n.Right)
	case *StaticCallExpr:
		return GetFirstToken(n.Class)
		if n.DoubleColonTkn != nil {
			return n.DoubleColonTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		return GetFirstToken(n.Call)
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Args) != 0 {
			return GetFirstToken(n.Args[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
	case *StaticPropertyFetchExpr:
		return GetFirstToken(n.Class)
		if n.DoubleColonTkn != nil {
			return n.DoubleColonTkn
		}
		return GetFirstToken(n.Property)
	case *StaticStmt:
		if n.StaticTkn != nil {
			return n.StaticTkn
		}
		if len(n.Vars) != 0 {
			return GetFirstToken(n.Vars[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *StaticVarStmt:
		if n.EqualTkn != nil {
			return n.EqualTkn
		}
		return GetFirstToken(n.Expr)
	case *StmtList:
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *String:
		if n.MinusTkn != nil {
			return n.MinusTkn
		}
		if n.StringTkn != nil {
			return n.StringTkn
		}
	case *SwitchStmt:
		if n.SwitchTkn != nil {
			return n.SwitchTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Cond)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if n.CaseSeparatorTkn != nil {
			return n.CaseSeparatorTkn
		}
		if len(n.Cases) != 0 {
			return GetFirstToken(n.Cases[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.EndSwitchTkn != nil {
			return n.EndSwitchTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *TernaryExpr:
		return GetFirstToken(n.Condition)
		if n.QuestionTkn != nil {
			return n.QuestionTkn
		}
		return GetFirstToken(n.IfTrue)
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.IfFalse)
	case *ThrowStmt:
		if n.ThrowTkn != nil {
			return n.ThrowTkn
		}
		return GetFirstToken(n.Expr)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *TraitAdaptationListStmt:
		if len(n.Adaptations) != 0 {
			return GetFirstToken(n.Adaptations[0])
		}
	case *TraitMethodRefStmt:
		return GetFirstToken(n.Trait)
	case *TraitStmt:
		if n.TraitTkn != nil {
			return n.TraitTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *TraitUseAliasStmt:
		if n.DoubleColonTkn != nil {
			return n.DoubleColonTkn
		}
		return GetFirstToken(n.Ref)
		if n.AsTkn != nil {
			return n.AsTkn
		}
		return GetFirstToken(n.Modifier)
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *TraitUsePrecedenceStmt:
		if n.DoubleColonTkn != nil {
			return n.DoubleColonTkn
		}
		return GetFirstToken(n.Ref)
		if n.InsteadofTkn != nil {
			return n.InsteadofTkn
		}
		if len(n.Insteadof) != 0 {
			return GetFirstToken(n.Insteadof[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *TraitUseStmt:
		if n.UseTkn != nil {
			return n.UseTkn
		}
		if len(n.Traits) != 0 {
			return GetFirstToken(n.Traits[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		return GetFirstToken(n.TraitAdaptationList)
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *TryStmt:
		if n.TryTkn != nil {
			return n.TryTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		if len(n.Stmts) != 0 {
			return GetFirstToken(n.Stmts[0])
		}
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
		if len(n.Catches) != 0 {
			return GetFirstToken(n.Catches[0])
		}
		return GetFirstToken(n.Finally)
	case *TypeCastExpr:
		if n.CastTkn != nil {
			return n.CastTkn
		}
		return GetFirstToken(n.Expr)
	case *UnaryMinusExpr:
		if n.MinusTkn != nil {
			return n.MinusTkn
		}
		return GetFirstToken(n.Expr)
	case *UnaryPlusExpr:
		if n.PlusTkn != nil {
			return n.PlusTkn
		}
		return GetFirstToken(n.Expr)
	case *UnsetCastExpr:
		if n.CastTkn != nil {
			return n.CastTkn
		}
		return GetFirstToken(n.Expr)
	case *UnsetStmt:
		if n.UnsetTkn != nil {
			return n.UnsetTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		if len(n.Vars) != 0 {
			return GetFirstToken(n.Vars[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *UseListStmt:
		if n.UseTkn != nil {
			return n.UseTkn
		}
		if len(n.Uses) != 0 {
			return GetFirstToken(n.Uses[0])
		}
		if len(n.SeparatorTkns) != 0 {
			return n.SeparatorTkns[0]
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *UseStmt:
		if n.NsSeparatorTkn != nil {
			return n.NsSeparatorTkn
		}
		if n.AsTkn != nil {
			return n.AsTkn
		}
	case *Var:
		if n.DollarTkn != nil {
			return n.DollarTkn
		}
		if n.OpenCurlyBracketTkn != nil {
			return n.OpenCurlyBracketTkn
		}
		return GetFirstToken(n.Expr)
		if n.CloseCurlyBracketTkn != nil {
			return n.CloseCurlyBracketTkn
		}
	case *WhileStmt:
		if n.WhileTkn != nil {
			return n.WhileTkn
		}
		if n.OpenParenthesisTkn != nil {
			return n.OpenParenthesisTkn
		}
		return GetFirstToken(n.Cond)
		if n.CloseParenthesisTkn != nil {
			return n.CloseParenthesisTkn
		}
		if n.ColonTkn != nil {
			return n.ColonTkn
		}
		return GetFirstToken(n.Stmt)
		if n.EndWhileTkn != nil {
			return n.EndWhileTkn
		}
		if n.SemiColonTkn != nil {
			return n.SemiColonTkn
		}
	case *YieldExpr:
		if n.YieldTkn != nil {
			return n.YieldTkn
		}
		return GetFirstToken(n.Key)
		if n.DoubleArrowTkn != nil {
			return n.DoubleArrowTkn
		}
		return GetFirstToken(n.Value)
	case *YieldFromExpr:
		if n.YieldFromTkn != nil {
			return n.YieldFromTkn
		}
		return GetFirstToken(n.Expr)
	default:
		panic(fmt.Sprintf(`unhandled type %T`, n))
	}
	return nil
}
