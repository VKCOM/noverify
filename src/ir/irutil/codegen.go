// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"path"
	"sort"
	"strings"
)

type packageData struct {
	name  string
	path  string
	scope *types.Scope
	types []*typeData
}

type typeData struct {
	name string
	info *types.Struct
}

type context struct {
	fset         *token.FileSet
	packages     []*packageData
	packagePaths []string
}

func main() {
	packages := []string{
		"ir",
	}

	ctx := context{
		fset:         token.NewFileSet(),
		packagePaths: packages,
	}
	for _, pkg := range packages {
		if err := loadPackage(&ctx, pkg); err != nil {
			log.Fatalf("load %s: %v", pkg, err)
		}
	}
	sortSymbols(&ctx)

	generateEqual(&ctx)
	generateClone(&ctx)
}

func generateClone(ctx *context) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by `codegen.go`. DO NOT EDIT.\n")
	buf.WriteString("package irutil\n")
	buf.WriteString("import (\n")
	for _, path := range importPaths(ctx.packagePaths) {
		buf.WriteString("  \"" + path + "\"\n")
	}
	buf.WriteString(")\n")
	buf.WriteString("func NodeClone(x ir.Node) ir.Node {\n")
	buf.WriteString("  if x == nil { return nil }\n")
	buf.WriteString("  switch x := x.(type) {\n")
	for _, pkg := range ctx.packages {
		for _, typ := range pkg.types {
			fmt.Fprintf(&buf, "  case *%s.%s:\n", pkg.name, typ.name)
			writeCloneCase(&buf, pkg, typ)
		}
	}
	buf.WriteString("  }\n")
	buf.WriteString("  panic(fmt.Sprintf(`unhandled type %T`, x))\n")
	buf.WriteString("}\n")

	output, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		log.Fatalf("gofmt: %v", err)
	}

	if err := ioutil.WriteFile("clone.go", output, 0666); err != nil {
		log.Fatalf("write file: %v", err)
	}
}

func formatType(typ types.Type) string {
	return types.TypeString(typ, func(pkg *types.Package) string {
		return pkg.Name()
	})
}

func hasNodeMembers(typ types.Type) bool {
	switch typ := typ.(type) {
	case *types.Pointer:
		return hasNodeMembers(typ.Elem())
	case *types.Named:
		return hasNodeMembers(typ.Underlying())
	case *types.Struct:
		for i := 0; i < typ.NumFields(); i++ {
			field := typ.Field(i)
			if hasNodeMembers(field.Type()) {
				return true
			}
		}
		return false
	case *types.Basic, *types.Map:
		return false
	}
	return true
}

func writeWalkCase(w *bytes.Buffer, pkg *packageData, typ *typeData) {
	for i := 0; i < typ.info.NumFields(); i++ {
		field := typ.info.Field(i)
		switch typeString := field.Type().String(); typeString {
		case "[]ir.Node":
			fmt.Fprintf(w, "    NodeSliceWalk(x.%[1]s, visit)\n", field.Name())
		case "github.com/VKCOM/noverify/src/php/parser/freefloating.Collection":
			// Do nothing.
		case "*github.com/VKCOM/noverify/src/php/parser/position.Position":
			// Do nothing.
		case "string", "bool":
			// Do nothing.
		default:
			if !strings.HasPrefix(typeString, "[]") {
				fmt.Fprintf(w, "    if x.%s != nil {\n", field.Name())
				if hasNodeMembers(field.Type()) {
					fmt.Fprintf(w, "      NodeWalk(x.%[1]s, visit)\n", field.Name())
				} else {
					fmt.Fprintf(w, "      visit(x.%[1]s)\n", field.Name())
				}
				fmt.Fprintf(w, "    }\n")
				continue
			}
			elemType := field.Type().(*types.Slice).Elem()
			fmt.Fprintf(w, "    for i := range x.%s {\n", field.Name())
			fmt.Fprintf(w, "      if x.%s[i] != nil {\n", field.Name())
			if hasNodeMembers(elemType) {
				fmt.Fprintf(w, "        NodeWalk(x.%s[i], visit)\n", field.Name())
			} else {
				fmt.Fprintf(w, "        visit(x.%s[i])\n", field.Name())
			}
			fmt.Fprintf(w, "      }\n")
			fmt.Fprintf(w, "    }\n")
		}
	}
}

func writeCloneCase(w *bytes.Buffer, pkg *packageData, typ *typeData) {
	// This clones all value-type fields.
	w.WriteString("    clone := *x\n")

	for i := 0; i < typ.info.NumFields(); i++ {
		field := typ.info.Field(i)
		switch typeString := field.Type().String(); typeString {
		case "[]ir.Node":
			fmt.Fprintf(w, "    clone.%[1]s = NodeSliceClone(x.%[1]s)\n", field.Name())
		case "github.com/VKCOM/noverify/src/php/parser/freefloating.Collection":
			// Do nothing.
		case "*github.com/VKCOM/noverify/src/php/parser/position.Position":
			// Do nothing.
		case "string", "bool":
			// Do nothing.
		default:
			if !strings.HasPrefix(typeString, "[]") {
				fmt.Fprintf(w, "    if x.%s != nil {\n", field.Name())
				fmt.Fprintf(w, "      clone.%[1]s = NodeClone(x.%[1]s).(%s)\n", field.Name(), formatType(field.Type()))
				fmt.Fprintf(w, "    }\n")
				continue
			}
			elemType := field.Type().(*types.Slice).Elem()
			fmt.Fprintf(w, "    {\n")
			fmt.Fprintf(w, "      sliceClone := make(%s, len(x.%s))\n", formatType(field.Type()), field.Name())
			fmt.Fprintf(w, "      for i := range x.%s {\n", field.Name())
			fmt.Fprintf(w, "        sliceClone[i] = NodeClone(x.%s[i]).(%s)\n", field.Name(), formatType(elemType))
			fmt.Fprintf(w, "      }\n")
			fmt.Fprintf(w, "      clone.%s = sliceClone\n", field.Name())
			fmt.Fprintf(w, "    }\n")
		}
	}
	w.WriteString("    return &clone\n")
}

func generateEqual(ctx *context) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by `codegen.go`. DO NOT EDIT.\n")
	buf.WriteString("package irutil\n")
	buf.WriteString("import (\n")
	for _, path := range importPaths(ctx.packagePaths) {
		buf.WriteString("  \"" + path + "\"\n")
	}
	buf.WriteString(")\n")
	buf.WriteString("func NodeEqual(x, y ir.Node) bool {\n")
	buf.WriteString("  if x == nil || y == nil { return x == y }\n")
	buf.WriteString("  switch x := x.(type) {\n")
	for _, pkg := range ctx.packages {
		for _, typ := range pkg.types {
			fmt.Fprintf(&buf, "  case *%s.%s:\n", pkg.name, typ.name)
			writeCompare(&buf, pkg, typ)
			buf.WriteString("    return true\n")
		}
	}
	buf.WriteString("  default:\n")
	buf.WriteString("    panic(fmt.Sprintf(`unhandled type %T`, x))\n")
	buf.WriteString("  }\n")
	buf.WriteString("}\n")

	output, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("gofmt: %v", err)
	}

	if err := ioutil.WriteFile("equal.go", output, 0666); err != nil {
		log.Fatalf("write file: %v", err)
	}
}

func writeCompare(w *bytes.Buffer, pkg *packageData, typ *typeData) {
	fmt.Fprintf(w, "    y, ok := y.(*%s.%s)\n", pkg.name, typ.name)
	w.WriteString("    if !ok || x == nil || y == nil { return x == y }\n")
	for i := 0; i < typ.info.NumFields(); i++ {
		field := typ.info.Field(i)
		switch typeString := field.Type().String(); typeString {
		case "string", "bool":
			fmt.Fprintf(w, "    if x.%[1]s != y.%[1]s { return false }\n", field.Name())
		case "[]ir.Node":
			fmt.Fprintf(w, "    if !NodeSliceEqual(x.%[1]s, y.%[1]s) { return false }\n", field.Name())
		case "github.com/VKCOM/noverify/src/php/parser/freefloating.Collection":
			// Do nothing.
		case "*github.com/VKCOM/noverify/src/php/parser/position.Position":
			// Do nothing.
		default:
			if !strings.HasPrefix(typeString, "[]") {
				fmt.Fprintf(w, "    if !NodeEqual(x.%[1]s, y.%[1]s) { return false }\n", field.Name())
				continue
			}
			fmt.Fprintf(w, "    if len(x.%[1]s) != len(y.%[1]s) { return false }\n", field.Name())
			fmt.Fprintf(w, "    for i := range x.%s {\n", field.Name())
			fmt.Fprintf(w, "      if !NodeEqual(x.%[1]s[i], y.%[1]s[i]) { return false }\n", field.Name())
			fmt.Fprintf(w, "    }\n")
		}
	}
}

func importPaths(packages []string) []string {
	paths := make([]string, len(packages))
	for i, pkg := range packages {
		paths[i] = "github.com/VKCOM/noverify/src/" + pkg
	}
	paths = append(paths, "fmt")
	return paths
}

var typechecker = types.Config{
	Importer: importer.For("source", nil),
}

func loadPackage(ctx *context, pkg string) error {
	pkgName := path.Base(pkg)
	parsedPkgs, err := parser.ParseDir(ctx.fset, "../../"+pkg, nil, 0)
	if err != nil {
		return err
	}
	astPkg, ok := parsedPkgs[pkgName]
	if !ok {
		return fmt.Errorf("package %s not found", pkgName)
	}
	astFiles := make([]*ast.File, 0, len(astPkg.Files))
	for _, f := range astPkg.Files {
		astFiles = append(astFiles, f)
	}
	var info types.Info
	typesPkg, err := typechecker.Check(pkg, ctx.fset, astFiles, &info)
	if err != nil {
		return err
	}
	root := typesPkg.Scope()
	result := &packageData{
		name:  pkgName,
		path:  pkg,
		scope: root,
	}
	for _, sym := range root.Names() {
		tn, ok := root.Lookup(sym).(*types.TypeName)
		if !ok {
			continue
		}
		named, ok := tn.Type().(*types.Named)
		if !ok {
			continue
		}
		structType, ok := named.Underlying().(*types.Struct)
		if !ok {
			continue
		}
		result.types = append(result.types, &typeData{
			name: tn.Name(),
			info: structType,
		})
	}
	ctx.packages = append(ctx.packages, result)
	return nil
}

func sortSymbols(ctx *context) {
	sort.Slice(ctx.packages, func(i, j int) bool {
		return ctx.packages[i].name < ctx.packages[j].name
	})
	for _, pkg := range ctx.packages {
		sort.Slice(pkg.types, func(i, j int) bool {
			return pkg.types[i].name < pkg.types[j].name
		})
	}
}
