// Code generated by the `ir/codegen` package. DO NOT EDIT.
package ir

import (
	"github.com/z7zmey/php-parser/pkg/token"
)

func handleToken(t *token.Token, cb func(*token.Token) bool) bool {
	if t == nil {
		return true
	}

	if !cb(t) {
		return false
	}

	needReturn := true
	for _, ff := range t.FreeFloating {
		needReturn = needReturn && handleToken(ff, cb)
	}

	return needReturn
}

func (n *AnonClassExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ClassTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *Argument) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.VariadicTkn, cb)
	handleToken(n.AmpersandTkn, cb)
}

func (n *ArrayDimFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenBracketTkn, cb)
	handleToken(n.CloseBracketTkn, cb)
}

func (n *ArrayExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ArrayTkn, cb)
	handleToken(n.OpenBracketTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseBracketTkn, cb)
}

func (n *ArrayItemExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EllipsisTkn, cb)
	handleToken(n.DoubleArrowTkn, cb)
	handleToken(n.AmpersandTkn, cb)
}

func (n *ArrowFunctionExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.StaticTkn, cb)
	handleToken(n.FnTkn, cb)
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.DoubleArrowTkn, cb)
}

func (n *Assign) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignBitwiseAnd) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignBitwiseOr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignBitwiseXor) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignCoalesce) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignConcat) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignDiv) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignMinus) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignMod) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignMul) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignPlus) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignPow) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignReference) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignShiftLeft) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *AssignShiftRight) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *BadString) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.MinusTkn, cb)
	handleToken(n.StringTkn, cb)
}

func (n *BitwiseAndExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *BitwiseNotExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.TildaTkn, cb)
}

func (n *BitwiseOrExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *BitwiseXorExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *BooleanAndExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *BooleanNotExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ExclamationTkn, cb)
}

func (n *BooleanOrExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *BreakStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.BreakTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *CaseStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.CaseTkn, cb)
	handleToken(n.CaseSeparatorTkn, cb)
}

func (n *CatchStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.CatchTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *ClassConstFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoubleColonTkn, cb)
}

func (n *ClassConstListStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ConstTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *ClassExtendsStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ExtendsTkn, cb)
}

func (n *ClassImplementsStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ImplementsTkn, cb)
	for _, tk := range n.ImplementsSeparatorTkns {
		handleToken(tk, cb)
	}
}

func (n *ClassMethodStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.FunctionTkn, cb)
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
}

func (n *ClassStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ClassTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *CloneExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.CloneTkn, cb)
}

func (n *ClosureExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.StaticTkn, cb)
	handleToken(n.FunctionTkn, cb)
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.UseTkn, cb)
	handleToken(n.UseOpenParenthesisTkn, cb)
	for _, tk := range n.UseSeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.UseCloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *ClosureUseExpr) IterateTokens(cb func(*token.Token) bool) {
}

func (n *CoalesceExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *ConcatExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *ConstFetchExpr) IterateTokens(cb func(*token.Token) bool) {
}

func (n *ConstListStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ConstTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *ConstantStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *ContinueStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ContinueTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *DeclareStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DeclareTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.EndDeclareTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *DefaultStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DefaultTkn, cb)
	handleToken(n.CaseSeparatorTkn, cb)
}

func (n *DivExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *Dnumber) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NumberTkn, cb)
}

func (n *DoStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoTkn, cb)
	handleToken(n.WhileTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *EchoStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EchoTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *ElseIfStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ElseIfTkn, cb)
	handleToken(n.ElseTkn, cb)
	handleToken(n.IfTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
}

func (n *ElseStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ElseTkn, cb)
	handleToken(n.ColonTkn, cb)
}

func (n *EmptyExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EmptyTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *Encapsed) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenQuoteTkn, cb)
	handleToken(n.CloseQuoteTkn, cb)
}

func (n *EncapsedStringPart) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EncapsedStrTkn, cb)
}

func (n *EqualExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *ErrorSuppressExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.AtTkn, cb)
}

func (n *EvalExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EvalTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *ExitExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ExitTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *ExpressionStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.SemiColonTkn, cb)
}

func (n *FinallyStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.FinallyTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *ForStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ForTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.InitSeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.InitSemiColonTkn, cb)
	for _, tk := range n.CondSeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CondSemiColonTkn, cb)
	for _, tk := range n.LoopSeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.EndForTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *ForeachStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ForeachTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.AsTkn, cb)
	handleToken(n.DoubleArrowTkn, cb)
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.EndForeachTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *FunctionCallExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *FunctionStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.FunctionTkn, cb)
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *GlobalStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.GlobalTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *GotoStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.GotoTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *GreaterExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *GreaterOrEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *GroupUseStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.UseTkn, cb)
	handleToken(n.LeadingNsSeparatorTkn, cb)
	handleToken(n.NsSeparatorTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *HaltCompilerStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.HaltCompilerTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *Heredoc) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenHeredocTkn, cb)
	handleToken(n.CloseHeredocTkn, cb)
}

func (n *IdenticalExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *Identifier) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.IdentifierTkn, cb)
}

func (n *IfStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.IfTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.EndIfTkn, cb)
	handleToken(n.SemiColonTkn, cb)
	handleToken(n.ElseTkn, cb)
}

func (n *ImportExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ImportTkn, cb)
}

func (n *InlineHTMLStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.InlineHTMLTkn, cb)
}

func (n *InstanceOfExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.InstanceOfTkn, cb)
}

func (n *InterfaceExtendsStmt) IterateTokens(cb func(*token.Token) bool) {
}

func (n *InterfaceStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.InterfaceTkn, cb)
	handleToken(n.ExtendsTkn, cb)
	for _, tk := range n.ExtendsSeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *IssetExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.IssetTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *LabelStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ColonTkn, cb)
}

func (n *ListExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ListTkn, cb)
	handleToken(n.OpenBracketTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseBracketTkn, cb)
}

func (n *Lnumber) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NumberTkn, cb)
}

func (n *LogicalAndExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *LogicalOrExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *LogicalXorExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *MagicConstant) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.MagicConstTkn, cb)
}

func (n *MethodCallExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ObjectOperatorTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *MinusExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *ModExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *MulExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *Name) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NameTkn, cb)
}

func (n *NamespaceStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NsTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *NewExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NewTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *NopStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.SemiColonTkn, cb)
}

func (n *NotEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *NotIdenticalExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *Nullable) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.QuestionTkn, cb)
}

func (n *Parameter) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.AmpersandTkn, cb)
	handleToken(n.VariadicTkn, cb)
	handleToken(n.EqualTkn, cb)
}

func (n *ParenExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *PlusExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *PostDecExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DecTkn, cb)
}

func (n *PostIncExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.IncTkn, cb)
}

func (n *PowExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *PreDecExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DecTkn, cb)
}

func (n *PreIncExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.IncTkn, cb)
}

func (n *PrintExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.PrintTkn, cb)
}

func (n *PropertyFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ObjectOperatorTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *PropertyListStmt) IterateTokens(cb func(*token.Token) bool) {
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *PropertyStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *ReferenceExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.AmpersandTkn, cb)
}

func (n *ReturnStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ReturnTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *Root) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EndTkn, cb)
}

func (n *ShellExecExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenBacktickTkn, cb)
	handleToken(n.CloseBacktickTkn, cb)
}

func (n *ShiftLeftExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *ShiftRightExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *SimpleVar) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DollarTkn, cb)
	handleToken(n.IdentifierTkn, cb)
}

func (n *SmallerExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *SmallerOrEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *SpaceshipExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpTkn, cb)
}

func (n *StaticCallExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoubleColonTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
}

func (n *StaticPropertyFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoubleColonTkn, cb)
}

func (n *StaticStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.StaticTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *StaticVarStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.EqualTkn, cb)
}

func (n *StmtList) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *String) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.MinusTkn, cb)
	handleToken(n.StringTkn, cb)
}

func (n *SwitchStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.SwitchTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CaseSeparatorTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.EndSwitchTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *TernaryExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.QuestionTkn, cb)
	handleToken(n.ColonTkn, cb)
}

func (n *ThrowStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.ThrowTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *TraitAdaptationListStmt) IterateTokens(cb func(*token.Token) bool) {
}

func (n *TraitMethodRefStmt) IterateTokens(cb func(*token.Token) bool) {
}

func (n *TraitStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.TraitTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *TraitUseAliasStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoubleColonTkn, cb)
	handleToken(n.AsTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *TraitUsePrecedenceStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DoubleColonTkn, cb)
	handleToken(n.InsteadofTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *TraitUseStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.UseTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *TryStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.TryTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *TypeCastExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.CastTkn, cb)
}

func (n *UnaryMinusExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.MinusTkn, cb)
}

func (n *UnaryPlusExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.PlusTkn, cb)
}

func (n *UnsetCastExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.CastTkn, cb)
}

func (n *UnsetStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.UnsetTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *UseListStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.UseTkn, cb)
	for _, tk := range n.SeparatorTkns {
		handleToken(tk, cb)
	}
	handleToken(n.SemiColonTkn, cb)
}

func (n *UseStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.NsSeparatorTkn, cb)
	handleToken(n.AsTkn, cb)
}

func (n *Var) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.DollarTkn, cb)
	handleToken(n.OpenCurlyBracketTkn, cb)
	handleToken(n.CloseCurlyBracketTkn, cb)
}

func (n *WhileStmt) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.WhileTkn, cb)
	handleToken(n.OpenParenthesisTkn, cb)
	handleToken(n.CloseParenthesisTkn, cb)
	handleToken(n.ColonTkn, cb)
	handleToken(n.EndWhileTkn, cb)
	handleToken(n.SemiColonTkn, cb)
}

func (n *YieldExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.YieldTkn, cb)
	handleToken(n.DoubleArrowTkn, cb)
}

func (n *YieldFromExpr) IterateTokens(cb func(*token.Token) bool) {
	handleToken(n.YieldFromTkn, cb)
}
