// Code generated by the `ir/codegen` package. DO NOT EDIT.
package ir

import (
	"github.com/z7zmey/php-parser/pkg/token"
)

func (n *AnonClassExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ClassTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *Argument) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.VariadicTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
}

func (n *ArrayDimFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseBracketTkn, cb) {
		return
	}
}

func (n *ArrayExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ArrayTkn, cb) {
		return
	}
	if !traverseToken(n.OpenBracketTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseBracketTkn, cb) {
		return
	}
}

func (n *ArrayItemExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EllipsisTkn, cb) {
		return
	}
	if !traverseToken(n.DoubleArrowTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
}

func (n *ArrowFunctionExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.StaticTkn, cb) {
		return
	}
	if !traverseToken(n.FnTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.DoubleArrowTkn, cb) {
		return
	}
}

func (n *Assign) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignBitwiseAnd) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignBitwiseOr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignBitwiseXor) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignCoalesce) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignConcat) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignDiv) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignMinus) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignMod) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignMul) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignPlus) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignPow) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignReference) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignShiftLeft) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *AssignShiftRight) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *BadString) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.MinusTkn, cb) {
		return
	}
	if !traverseToken(n.StringTkn, cb) {
		return
	}
}

func (n *BitwiseAndExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *BitwiseNotExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.TildaTkn, cb) {
		return
	}
}

func (n *BitwiseOrExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *BitwiseXorExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *BooleanAndExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *BooleanNotExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ExclamationTkn, cb) {
		return
	}
}

func (n *BooleanOrExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *BreakStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.BreakTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *CaseStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.CaseTkn, cb) {
		return
	}
	if !traverseToken(n.CaseSeparatorTkn, cb) {
		return
	}
}

func (n *CatchStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.CatchTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *ClassConstFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoubleColonTkn, cb) {
		return
	}
}

func (n *ClassConstListStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ConstTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *ClassExtendsStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ExtendsTkn, cb) {
		return
	}
}

func (n *ClassImplementsStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ImplementsTkn, cb) {
		return
	}
	for _, tk := range n.ImplementsSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
}

func (n *ClassMethodStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.FunctionTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
}

func (n *ClassStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ClassTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *CloneExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.CloneTkn, cb) {
		return
	}
}

func (n *CloseTagStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.TagTkn, cb) {
		return
	}
}

func (n *ClosureExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.StaticTkn, cb) {
		return
	}
	if !traverseToken(n.FunctionTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *ClosureUsesExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.UseTkn, cb) {
		return
	}
	if !traverseToken(n.UseOpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.UseSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.UseCloseParenthesisTkn, cb) {
		return
	}
}

func (n *CoalesceExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *ConcatExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *ConstFetchExpr) IterateTokens(cb func(*token.Token) bool) {
}

func (n *ConstListStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ConstTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *ConstantStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *ContinueStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ContinueTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *DeclareStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DeclareTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.EndDeclareTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *DefaultStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DefaultTkn, cb) {
		return
	}
	if !traverseToken(n.CaseSeparatorTkn, cb) {
		return
	}
}

func (n *DivExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *Dnumber) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NumberTkn, cb) {
		return
	}
}

func (n *DoStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoTkn, cb) {
		return
	}
	if !traverseToken(n.WhileTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *EchoStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EchoTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *ElseIfStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ElseIfTkn, cb) {
		return
	}
	if !traverseToken(n.ElseTkn, cb) {
		return
	}
	if !traverseToken(n.IfTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
}

func (n *ElseStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ElseTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
}

func (n *EmptyExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EmptyTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *Encapsed) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenQuoteTkn, cb) {
		return
	}
	if !traverseToken(n.CloseQuoteTkn, cb) {
		return
	}
}

func (n *EncapsedStringPart) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EncapsedStrTkn, cb) {
		return
	}
}

func (n *EqualExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *ErrorSuppressExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.AtTkn, cb) {
		return
	}
}

func (n *EvalExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EvalTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *ExitExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ExitTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *ExpressionStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *FinallyStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.FinallyTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *ForStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ForTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.InitSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.InitSemiColonTkn, cb) {
		return
	}
	for _, tk := range n.CondSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CondSemiColonTkn, cb) {
		return
	}
	for _, tk := range n.LoopSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.EndForTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *ForeachStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ForeachTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.AsTkn, cb) {
		return
	}
	if !traverseToken(n.DoubleArrowTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.EndForeachTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *FunctionCallExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *FunctionStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.FunctionTkn, cb) {
		return
	}
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *GlobalStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.GlobalTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *GotoStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.GotoTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *GreaterExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *GreaterOrEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *GroupUseStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.UseTkn, cb) {
		return
	}
	if !traverseToken(n.LeadingNsSeparatorTkn, cb) {
		return
	}
	if !traverseToken(n.NsSeparatorTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *HaltCompilerStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.HaltCompilerTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *Heredoc) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenHeredocTkn, cb) {
		return
	}
	if !traverseToken(n.CloseHeredocTkn, cb) {
		return
	}
}

func (n *IdenticalExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *Identifier) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.IdentifierTkn, cb) {
		return
	}
}

func (n *IfStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.IfTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.EndIfTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
	if !traverseToken(n.ElseTkn, cb) {
		return
	}
}

func (n *ImportExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ImportTkn, cb) {
		return
	}
}

func (n *InlineHTMLStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.InlineHTMLTkn, cb) {
		return
	}
}

func (n *InstanceOfExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.InstanceOfTkn, cb) {
		return
	}
}

func (n *InterfaceExtendsStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ExtendsTkn, cb) {
		return
	}
	for _, tk := range n.ExtendsSeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
}

func (n *InterfaceStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.InterfaceTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *IssetExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.IssetTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *LabelStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
}

func (n *ListExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ListTkn, cb) {
		return
	}
	if !traverseToken(n.OpenBracketTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseBracketTkn, cb) {
		return
	}
}

func (n *Lnumber) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NumberTkn, cb) {
		return
	}
}

func (n *LogicalAndExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *LogicalOrExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *LogicalXorExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *MagicConstant) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.MagicConstTkn, cb) {
		return
	}
}

func (n *MethodCallExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ObjectOperatorTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *MinusExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *ModExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *MulExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *Name) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NameTkn, cb) {
		return
	}
}

func (n *NamespaceStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NsTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *NewExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NewTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *NopStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *NotEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *NotIdenticalExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *Nullable) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.QuestionTkn, cb) {
		return
	}
}

func (n *Parameter) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
	if !traverseToken(n.VariadicTkn, cb) {
		return
	}
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *ParenExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *PlusExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *PostDecExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DecTkn, cb) {
		return
	}
}

func (n *PostIncExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.IncTkn, cb) {
		return
	}
}

func (n *PowExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *PreDecExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DecTkn, cb) {
		return
	}
}

func (n *PreIncExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.IncTkn, cb) {
		return
	}
}

func (n *PrintExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.PrintTkn, cb) {
		return
	}
}

func (n *PropertyFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ObjectOperatorTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *PropertyListStmt) IterateTokens(cb func(*token.Token) bool) {
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *PropertyStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *ReferenceExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.AmpersandTkn, cb) {
		return
	}
}

func (n *ReturnStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ReturnTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *Root) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EndTkn, cb) {
		return
	}
}

func (n *ShellExecExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenBacktickTkn, cb) {
		return
	}
	if !traverseToken(n.CloseBacktickTkn, cb) {
		return
	}
}

func (n *ShiftLeftExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *ShiftRightExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *SimpleVar) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DollarTkn, cb) {
		return
	}
	if !traverseToken(n.IdentifierTkn, cb) {
		return
	}
}

func (n *SmallerExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *SmallerOrEqualExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *SpaceshipExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpTkn, cb) {
		return
	}
}

func (n *StaticCallExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoubleColonTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
}

func (n *StaticPropertyFetchExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoubleColonTkn, cb) {
		return
	}
}

func (n *StaticStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.StaticTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *StaticVarStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.EqualTkn, cb) {
		return
	}
}

func (n *StmtList) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *String) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.MinusTkn, cb) {
		return
	}
	if !traverseToken(n.StringTkn, cb) {
		return
	}
}

func (n *SwitchStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.SwitchTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CaseSeparatorTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.EndSwitchTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *TernaryExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.QuestionTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
}

func (n *ThrowStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.ThrowTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *TraitAdaptationListStmt) IterateTokens(cb func(*token.Token) bool) {
}

func (n *TraitMethodRefStmt) IterateTokens(cb func(*token.Token) bool) {
}

func (n *TraitStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.TraitTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *TraitUseAliasStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoubleColonTkn, cb) {
		return
	}
	if !traverseToken(n.AsTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *TraitUsePrecedenceStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DoubleColonTkn, cb) {
		return
	}
	if !traverseToken(n.InsteadofTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *TraitUseStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.UseTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *TryStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.TryTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *TypeCastExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.CastTkn, cb) {
		return
	}
}

func (n *UnaryMinusExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.MinusTkn, cb) {
		return
	}
}

func (n *UnaryPlusExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.PlusTkn, cb) {
		return
	}
}

func (n *UnsetCastExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.CastTkn, cb) {
		return
	}
}

func (n *UnsetStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.UnsetTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *UseListStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.UseTkn, cb) {
		return
	}
	for _, tk := range n.SeparatorTkns {
		if !traverseToken(tk, cb) {
			return
		}
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *UseStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.NsSeparatorTkn, cb) {
		return
	}
	if !traverseToken(n.AsTkn, cb) {
		return
	}
}

func (n *Var) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.DollarTkn, cb) {
		return
	}
	if !traverseToken(n.OpenCurlyBracketTkn, cb) {
		return
	}
	if !traverseToken(n.CloseCurlyBracketTkn, cb) {
		return
	}
}

func (n *WhileStmt) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.WhileTkn, cb) {
		return
	}
	if !traverseToken(n.OpenParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.CloseParenthesisTkn, cb) {
		return
	}
	if !traverseToken(n.ColonTkn, cb) {
		return
	}
	if !traverseToken(n.EndWhileTkn, cb) {
		return
	}
	if !traverseToken(n.SemiColonTkn, cb) {
		return
	}
}

func (n *YieldExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.YieldTkn, cb) {
		return
	}
	if !traverseToken(n.DoubleArrowTkn, cb) {
		return
	}
}

func (n *YieldFromExpr) IterateTokens(cb func(*token.Token) bool) {
	if !traverseToken(n.YieldFromTkn, cb) {
		return
	}
}
